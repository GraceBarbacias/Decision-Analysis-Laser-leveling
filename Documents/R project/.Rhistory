net_benefits <- intervention_LLL_benefits - intervention_cost
# save result in result_interv (result intervention):
result_interv <- net_benefits}
# if the decision was to NOT implement LLL:
if (!intervention_LLL){
net_benefits <- rice_normal_benefits - intervention_cost  # intervention-cost should not change anything here
# save result in result_n_interv (result NO intervention):
result_n_interv <- net_benefits}
} #close intervention loop bracket
NPV_interv <-
discount(result_interv, discount_rate, calculate_NPV = TRUE)
NPV_n_interv <-
discount(result_n_interv, discount_rate, calculate_NPV = TRUE)
# Beware, if you do not name your outputs (left-hand side of the equal sign) in the return section,
# the variables will be called output_1, _2, etc.
return(list(LLL_NPV = NPV_interv,
NO_LLL_NPV = NPV_n_interv,
NPV_LLL_added_value = NPV_interv - NPV_n_interv,
Cashflow_LLL_added_value = result_interv - result_n_interv))
}
#   # Estimate the final results from the model
#   final_result <- income - Production_cost
#
#   # Generate the list of outputs from the Monte Carlo simulation
#   return(list(final_result = final_result))
# }
#
# # Run the Monte Carlo simulation using the model function
# example_mc_simulation_BAU <- mcSimulation(estimate = as.estimate(input_estimates_BAU),
#                               model_function = LLL_model_function,
#                               numberOfModelRuns = 800,
#                               functionSyntax = "plainNames")
#
# example_mc_simulation_BAU
#
# plot_distributions(mcSimulation_object = example_mc_simulation_BAU,
#                    vars = "final_result",
#                    method = "boxplot_density",
#                    old_names = "final_result",
#                    new_names = "Outcome distribution for profits")
# Generate a random seed
random_seed <- as.integer(Sys.time())  # Get the current time in seconds and convert it to an integer
# Set the random seed
set.seed(random_seed)
# Print the random seed
print(random_seed)
# Monte Carlo simulation results R code:
mcSimulation_results <- decisionSupport::mcSimulation(
estimate = decisionSupport::estimate_read_csv("Test_Input.csv", sep = ';', strip.white = TRUE),
model_function = LLL_model_function,
numberOfModelRuns = 1e3, #run 1,000 times
functionSyntax = "plainNames"
)
library(decisionSupport)
# R code for vizualisation of results:
decisionSupport::plot_distributions(mcSimulation_object = mcSimulation_results,
vars = c("LLL_NPV", "NO_LLL_NPV"),
method = 'smooth_simple_overlay',
base_size = 12,
colors = c("#FFC300", "#9f3ee2"))
decisionSupport::plot_distributions(mcSimulation_object = mcSimulation_results,
vars = c("LLL_NPV", "NO_LLL_NPV"),
method = 'hist_simple_overlay',
base_size = 12,
colors = c("#FFC300", "#9f3ee2"))
NPV_names = c("Rice Production with Laser Leveling NPV", "Conventional Rice Production NPV")
decisionSupport::plot_distributions(mcSimulation_object = mcSimulation_results,
vars = c("LLL_NPV", "NO_LLL_NPV"),
method = 'boxplot',
new_names = "NPV_names",
base_size = 12,
colors = c("#FFC300", "#9f3ee2"))
decisionSupport::plot_distributions(mcSimulation_object = mcSimulation_results,
vars = "NPV_LLL_added_value",
method = 'boxplot_density',
base_size = 12,
colors = "#FFC300")
plot_cashflow(mcSimulation_object = mcSimulation_results, cashflow_var_name = "Cashflow_LLL_added_value")
library(decisionSupport)
#select the 3rd outcome variable "NPV_LLL_added_value" from the mcSimulation results and run PLS simulation
pls_result <- plsr.mcSimulation(object = mcSimulation_results,
resultName = names(mcSimulation_results$y)[3], ncomp = 1)
input_table <- read.csv("Test_Input.csv")
plot_pls(pls_result, input_table = input_table, threshold = 0)
#here we subset the outputs from the mcSimulation function (y) by selecting the correct variables
# this should be done by the user (be sure to run the multi_EVPI only on the variables that the user wants)
mcSimulation_table <- data.frame(mcSimulation_results$x, mcSimulation_results$y[1:3])
evpi <- multi_EVPI(mc = mcSimulation_table, first_out_var = "Interv_NPV")
mcSimulation_results$y[1:3]
#Input data for Business as usual (BAU) scenario
#Production cost consisted of: (1) land use; (2) service costs of mechanized operations such as land preparation, mechanical transplanting, fertilizer and pesticide applications and combine harvesting; (3) agronomic inputs including seeds, fertilizer and pesticide; and, (4) labor.
input_estimates_BAU<- data.frame(variable = c("Yield", "Market_price", "Production_cost"),
lower = c(4, 350, 2300),
median = NA,
upper = c(7, 450, 3300),
distribution = c("posnorm", "posnorm", "posnorm"),
label = c("Yield (tonne/ha)", "Price (USD/tonne)", "Production cost (USD/ha)"),
Description = c("Yield in a rice field without LL",
"Price of rice in a normal season",
"Production costs in a normal season"))
input_estimates_BAU
LLL_model_function <- function(x, varnames){
# calculate ex-ante risks: impact the implementation of interventions ####
#
intervention_NonColabInvolvEvent <-
chance_event(intervention_NonPColabInvolv, 1, 0, n = 1)
# chance_event chooses with probability "intervention_NonColabInvolv" the first scenario (1 in this case), otherwise 0 (no involvement)
# benefits of rice cultivation WITH LLL:
precalc_intervention_LLL <-
vv(intervention_rice_yield_t_ha, var_CV, n_years) *
vv(intervention_rice_area_ha, var_CV, n_years) *
vv(rice_price_USD_t, var_CV, n_years)
# benefits of rice cultivation WITHOUT LLL:
precalc_ground_truth_normal_rice_production <-
vv(rice_yield_t_ha, var_CV, n_years) *
vv(rice_area_ha, var_CV, n_years) *
vv(rice_price_USD_t, var_CV, n_years)
#  Intervention Preamble ####
# Run a simulation for both the application of LLL and the normal scenario without it:
for (intervention_LLL in c(FALSE,TRUE))
{
# Set the preambles for the case if LLL application:
if (intervention_LLL)
{
event_LLL <- TRUE
event_LLL_cost <- TRUE
event_LLL_PlanningCost <- TRUE
event_normal_rice_prod <- FALSE
# Set the preambles for the normal rice production scenario
} else
{
event_LLL <- FALSE
event_LLL_cost <- FALSE
event_LLL_PlanningCost <- FALSE
event_normal_rice_prod <- TRUE
}
if (intervention_NonColabInvolvEvent) {
# only relevant if selected by chance and = TRUE
# if this condition is TRUE the implementation of LLL will be planned but not executed
event_LLL <- FALSE # no LLL applied
event_LLL_cost <- FALSE # no establishment costs are created (planning costs however may occur)
event_normal_rice_prod <- TRUE # the normal scenario takes place
}
#  Intervention ####
# summing up the investment costs if LLL is applied or not
if (event_LLL_cost) {
investment_cost_LLL <- establishment_cost_LLL
} else
investment_cost_LLL <- 0
# calculating the planning costs
if (event_LLL_PlanningCost) {
plan_cost_intervention_LLL <- intervention_communication_cost +
intervention_zoning_cost
} else
plan_cost_intervention_LLL <- 0
# calculating the maintenance costs, initializing the array with 0 costs for the first year:
maintenance_cost <- rep(0, n_years)
# Cost of the application of LLL per year
if (event_LLL_cost)
maintenance_cost <-
maintenance_cost +
# add a variation of the variable over the years
decisionSupport::vv(maintenance_cost, var_CV, n_years)
# First, all maintenance costs are stored in the variable:
intervention_cost <- maintenance_cost
# in the first year the establishment costs and planning costs are added:
intervention_cost[1] <-
intervention_cost[1] +
investment_cost_LLL +
plan_cost_intervention_LLL
#### Benefits from  cultivation in the intervention strips ####
# Now all benefits of the intervention will be calculated
# event_LLL is 0 if the introduction of LLL does not take place, thereby the gains would be multiplied by 0 = become 0
# Benefits of intervention LLL:
intervention_LLL_benefits <-
as.numeric(event_LLL) * precalc_intervention_LLL
# Benefits of normal rice production (ground truth):
rice_normal_benefits <-
as.numeric(event_normal_rice_prod) *   precalc_ground_truth_normal_rice_production
# Total benefits from crop production                       ####
# combined benefits (in reality: intervention_LLL_benefits + 0 OR rice_normal_benefits + 0)
#rice_production <- intervention_LLL_benefits + rice_normal_benefits #not needed since we separate the cases in the next part
# if the decision was to implement LLL:
if (intervention_LLL){
net_benefits <- intervention_LLL_benefits - intervention_cost
# save result in result_interv (result intervention):
result_interv <- net_benefits}
# if the decision was to NOT implement LLL:
if (!intervention_LLL){
net_benefits <- rice_normal_benefits - intervention_cost  # intervention-cost should not change anything here
# save result in result_n_interv (result NO intervention):
result_n_interv <- net_benefits}
} #close intervention loop bracket
NPV_interv <-
discount(result_interv, discount_rate, calculate_NPV = TRUE)
NPV_n_interv <-
discount(result_n_interv, discount_rate, calculate_NPV = TRUE)
# Beware, if you do not name your outputs (left-hand side of the equal sign) in the return section,
# the variables will be called output_1, _2, etc.
return(list(LLL_NPV = NPV_interv,
NO_LLL_NPV = NPV_n_interv,
NPV_LLL_added_value = NPV_interv - NPV_n_interv,
Cashflow_LLL_added_value = result_interv - result_n_interv))
}
#   # Estimate the final results from the model
#   final_result <- income - Production_cost
#
#   # Generate the list of outputs from the Monte Carlo simulation
#   return(list(final_result = final_result))
# }
#
# # Run the Monte Carlo simulation using the model function
# example_mc_simulation_BAU <- mcSimulation(estimate = as.estimate(input_estimates_BAU),
#                               model_function = LLL_model_function,
#                               numberOfModelRuns = 800,
#                               functionSyntax = "plainNames")
#
# example_mc_simulation_BAU
#
# plot_distributions(mcSimulation_object = example_mc_simulation_BAU,
#                    vars = "final_result",
#                    method = "boxplot_density",
#                    old_names = "final_result",
#                    new_names = "Outcome distribution for profits")
# Generate a random seed
random_seed <- as.integer(Sys.time())  # Get the current time in seconds and convert it to an integer
# Set the random seed
set.seed(random_seed)
# Print the random seed
print(random_seed)
# Monte Carlo simulation results R code:
mcSimulation_results <- decisionSupport::mcSimulation(
estimate = decisionSupport::estimate_read_csv("Test_Input.csv", sep = ';', strip.white = TRUE),
model_function = LLL_model_function,
numberOfModelRuns = 1e3, #run 1,000 times
functionSyntax = "plainNames"
)
library(decisionSupport)
# R code for vizualisation of results:
decisionSupport::plot_distributions(mcSimulation_object = mcSimulation_results,
vars = c("LLL_NPV", "NO_LLL_NPV"),
method = 'smooth_simple_overlay',
base_size = 12,
colors = c("#FFC300", "#9f3ee2"))
decisionSupport::plot_distributions(mcSimulation_object = mcSimulation_results,
vars = c("LLL_NPV", "NO_LLL_NPV"),
method = 'hist_simple_overlay',
base_size = 12,
colors = c("#FFC300", "#9f3ee2"))
NPV_names = c("Rice Production with Laser Leveling NPV", "Conventional Rice Production NPV")
decisionSupport::plot_distributions(mcSimulation_object = mcSimulation_results,
vars = c("LLL_NPV", "NO_LLL_NPV"),
method = 'boxplot',
new_names = "NPV_names",
base_size = 12,
colors = c("#FFC300", "#9f3ee2"))
decisionSupport::plot_distributions(mcSimulation_object = mcSimulation_results,
vars = "NPV_LLL_added_value",
method = 'boxplot_density',
base_size = 12,
colors = "#FFC300")
plot_cashflow(mcSimulation_object = mcSimulation_results, cashflow_var_name = "Cashflow_LLL_added_value")
library(decisionSupport)
#select the 3rd outcome variable "NPV_LLL_added_value" from the mcSimulation results and run PLS simulation
pls_result <- plsr.mcSimulation(object = mcSimulation_results,
resultName = names(mcSimulation_results$y)[3], ncomp = 1)
input_table <- read.csv("Test_Input.csv")
plot_pls(pls_result, input_table = input_table, threshold = 0)
#here we subset the outputs from the mcSimulation function (y) by selecting the correct variables
# this should be done by the user (be sure to run the multi_EVPI only on the variables that the user wants)
mcSimulation_table <- data.frame(mcSimulation_results$x, mcSimulation_results$y[1:3])
evpi <- multi_EVPI(mc = mcSimulation_table, first_out_var = "Interv_NPV")
#here we subset the outputs from the mcSimulation function (y) by selecting the correct variables
# this should be done by the user (be sure to run the multi_EVPI only on the variables that the user wants)
mcSimulation_table <- data.frame(mcSimulation_results$x, mcSimulation_results$y[1:3])
evpi <- multi_EVPI(mc = mcSimulation_table, first_out_var = "LLL_NPV")
#> [1] "Processing 3 output variables. This can take some time."
#> [1] "Output variable 1 (LLL_NPV) completed."
#> [1] "Output variable 2 (NO_LLL_NPV) completed."
#> [1] "Output variable 3 (NPV_LLL_added_value) completed."
#> plot_evpi(evpi, decision_vars = "NPV_decision_do")
#> Warning: There are no variables with a positive EVPI. You probably do not need a
#> plot for that.
#>
compound_figure(mcSimulation_object = mcSimulation_results, input_table = input_table, plsrResults = pls_result, EVPIresults = evpi, decision_var_name = "NPV_LLL_added_value", cashflow_var_name = "Cashflow_LLL_added_value", base_size = 7)
pls_result
PLS simulation
mcSimulation_results$y)[3]
(mcSimulation_results$y)[3]
library(decisionSupport)
# R code for vizualisation of results:
decisionSupport::plot_distributions(mcSimulation_object = mcSimulation_results,
vars = c("LLL_NPV", "NO_LLL_NPV"),
method = 'smooth_simple_overlay',
base_size = 12,
colors = c("#FFC300", "#9f3ee2"))
decisionSupport::plot_distributions(mcSimulation_object = mcSimulation_results,
vars = c("LLL_NPV", "NO_LLL_NPV"),
method = 'hist_simple_overlay',
base_size = 12,
colors = c("#FFC300", "#9f3ee2"))
NPV_names = c("Rice Production with Laser Leveling NPV", "Conventional Rice Production NPV")
decisionSupport::plot_distributions(mcSimulation_object = mcSimulation_results,
vars = c("LLL_NPV", "NO_LLL_NPV"),
method = 'boxplot',
new_names = "NPV_names",
base_size = 12,
colors = c("#FFC300", "#9f3ee2"))
decisionSupport::plot_distributions(mcSimulation_object = mcSimulation_results,
vars = "NPV_LLL_added_value",
method = 'boxplot_density',
base_size = 12,
colors = "#FFC300")
plot_cashflow(mcSimulation_object = mcSimulation_results, cashflow_var_name = "Cashflow_LLL_added_value")
library(decisionSupport)
#select the 3rd outcome variable "NPV_LLL_added_value" from the mcSimulation results and run PLS simulation
pls_result <- plsr.mcSimulation(object = mcSimulation_results,
resultName = names(mcSimulation_results$y)[3], ncomp = 1)
input_table <- read.csv("Test_Input.csv")
plot_pls(pls_result, input_table = input_table, threshold = 0)
?left_join.data.frame
#Input data for Business as usual (BAU) scenario
#Production cost consisted of: (1) land use; (2) service costs of mechanized operations such as land preparation, mechanical transplanting, fertilizer and pesticide applications and combine harvesting; (3) agronomic inputs including seeds, fertilizer and pesticide; and, (4) labor.
input_estimates_BAU<- data.frame(variable = c("Yield", "Market_price", "Production_cost"),
lower = c(4, 350, 2300),
median = NA,
upper = c(7, 450, 3300),
distribution = c("posnorm", "posnorm", "posnorm"),
label = c("Yield (tonne/ha)", "Price (USD/tonne)", "Production cost (USD/ha)"),
Description = c("Yield in a rice field without LL",
"Price of rice in a normal season",
"Production costs in a normal season"))
input_estimates_BAU
LLL_model_function <- function(x, varnames){
# calculate ex-ante risks: impact the implementation of interventions ####
#
intervention_NonColabInvolvEvent <-
chance_event(intervention_NonPColabInvolv, 1, 0, n = 1)
# chance_event chooses with probability "intervention_NonColabInvolv" the first scenario (1 in this case), otherwise 0 (no involvement)
# benefits of rice cultivation WITH LLL:
precalc_intervention_LLL <-
vv(intervention_rice_yield_t_ha, var_CV, n_years) *
vv(intervention_rice_area_ha, var_CV, n_years) *
vv(rice_price_USD_t, var_CV, n_years)
# benefits of rice cultivation WITHOUT LLL:
precalc_ground_truth_normal_rice_production <-
vv(rice_yield_t_ha, var_CV, n_years) *
vv(rice_area_ha, var_CV, n_years) *
vv(rice_price_USD_t, var_CV, n_years)
#  Intervention Preamble ####
# Run a simulation for both the application of LLL and the normal scenario without it:
for (intervention_LLL in c(FALSE,TRUE))
{
# Set the preambles for the case if LLL application:
if (intervention_LLL)
{
event_LLL <- TRUE
event_LLL_cost <- TRUE
event_LLL_PlanningCost <- TRUE
event_normal_rice_prod <- FALSE
# Set the preambles for the normal rice production scenario
} else
{
event_LLL <- FALSE
event_LLL_cost <- FALSE
event_LLL_PlanningCost <- FALSE
event_normal_rice_prod <- TRUE
}
if (intervention_NonColabInvolvEvent) {
# only relevant if selected by chance and = TRUE
# if this condition is TRUE the implementation of LLL will be planned but not executed
event_LLL <- FALSE # no LLL applied
event_LLL_cost <- FALSE # no establishment costs are created (planning costs however may occur)
event_normal_rice_prod <- TRUE # the normal scenario takes place
}
#  Intervention ####
# summing up the investment costs if LLL is applied or not
if (event_LLL_cost) {
investment_cost_LLL <- establishment_cost_LLL
} else
investment_cost_LLL <- 0
# calculating the planning costs
if (event_LLL_PlanningCost) {
plan_cost_intervention_LLL <- intervention_communication_cost +
intervention_zoning_cost
} else
plan_cost_intervention_LLL <- 0
# calculating the maintenance costs, initializing the array with 0 costs for the first year:
maintenance_cost <- rep(0, n_years)
# Cost of the application of LLL per year
if (event_LLL_cost)
maintenance_cost <-
maintenance_cost +
# add a variation of the variable over the years
decisionSupport::vv(maintenance_cost, var_CV, n_years)
# First, all maintenance costs are stored in the variable:
intervention_cost <- maintenance_cost
# in the first year the establishment costs and planning costs are added:
intervention_cost[1] <-
intervention_cost[1] +
investment_cost_LLL +
plan_cost_intervention_LLL
#### Benefits from  cultivation in the intervention strips ####
# Now all benefits of the intervention will be calculated
# event_LLL is 0 if the introduction of LLL does not take place, thereby the gains would be multiplied by 0 = become 0
# Benefits of intervention LLL:
intervention_LLL_benefits <-
as.numeric(event_LLL) * precalc_intervention_LLL
# Benefits of normal rice production (ground truth):
rice_normal_benefits <-
as.numeric(event_normal_rice_prod) *   precalc_ground_truth_normal_rice_production
# Total benefits from crop production                       ####
# combined benefits (in reality: intervention_LLL_benefits + 0 OR rice_normal_benefits + 0)
#rice_production <- intervention_LLL_benefits + rice_normal_benefits #not needed since we separate the cases in the next part
# if the decision was to implement LLL:
if (intervention_LLL){
net_benefits <- intervention_LLL_benefits - intervention_cost
# save result in result_interv (result intervention):
result_interv <- net_benefits}
# if the decision was to NOT implement LLL:
if (!intervention_LLL){
net_benefits <- rice_normal_benefits - intervention_cost  # intervention-cost should not change anything here
# save result in result_n_interv (result NO intervention):
result_n_interv <- net_benefits}
} #close intervention loop bracket
NPV_interv <-
discount(result_interv, discount_rate, calculate_NPV = TRUE)
NPV_n_interv <-
discount(result_n_interv, discount_rate, calculate_NPV = TRUE)
# Beware, if you do not name your outputs (left-hand side of the equal sign) in the return section,
# the variables will be called output_1, _2, etc.
return(list(LLL_NPV = NPV_interv,
NO_LLL_NPV = NPV_n_interv,
NPV_LLL_added_value = NPV_interv - NPV_n_interv,
Cashflow_LLL_added_value = result_interv - result_n_interv))
}
#   # Estimate the final results from the model
#   final_result <- income - Production_cost
#
#   # Generate the list of outputs from the Monte Carlo simulation
#   return(list(final_result = final_result))
# }
#
# # Run the Monte Carlo simulation using the model function
# example_mc_simulation_BAU <- mcSimulation(estimate = as.estimate(input_estimates_BAU),
#                               model_function = LLL_model_function,
#                               numberOfModelRuns = 800,
#                               functionSyntax = "plainNames")
#
# example_mc_simulation_BAU
#
# plot_distributions(mcSimulation_object = example_mc_simulation_BAU,
#                    vars = "final_result",
#                    method = "boxplot_density",
#                    old_names = "final_result",
#                    new_names = "Outcome distribution for profits")
# Generate a random seed
random_seed <- as.integer(Sys.time())  # Get the current time in seconds and convert it to an integer
# Set the random seed
set.seed(random_seed)
# Print the random seed
print(random_seed)
# Monte Carlo simulation results R code:
mcSimulation_results <- decisionSupport::mcSimulation(
estimate = decisionSupport::estimate_read_csv("Test_Input.csv", sep = ';', strip.white = TRUE),
model_function = LLL_model_function,
numberOfModelRuns = 1e3, #run 1,000 times
functionSyntax = "plainNames"
)
library(decisionSupport)
# R code for vizualisation of results:
decisionSupport::plot_distributions(mcSimulation_object = mcSimulation_results,
vars = c("LLL_NPV", "NO_LLL_NPV"),
method = 'smooth_simple_overlay',
base_size = 12,
colors = c("#FFC300", "#9f3ee2"))
decisionSupport::plot_distributions(mcSimulation_object = mcSimulation_results,
vars = c("LLL_NPV", "NO_LLL_NPV"),
method = 'hist_simple_overlay',
base_size = 12,
colors = c("#FFC300", "#9f3ee2"))
NPV_names = c("Rice Production with Laser Leveling NPV", "Conventional Rice Production NPV")
decisionSupport::plot_distributions(mcSimulation_object = mcSimulation_results,
vars = c("LLL_NPV", "NO_LLL_NPV"),
method = 'boxplot',
new_names = "NPV_names",
base_size = 12,
colors = c("#FFC300", "#9f3ee2"))
decisionSupport::plot_distributions(mcSimulation_object = mcSimulation_results,
vars = "NPV_LLL_added_value",
method = 'boxplot_density',
base_size = 12,
colors = "#FFC300")
plot_cashflow(mcSimulation_object = mcSimulation_results, cashflow_var_name = "Cashflow_LLL_added_value")
library(decisionSupport)
#select the 3rd outcome variable "NPV_LLL_added_value" from the mcSimulation results and run PLS simulation
pls_result <- plsr.mcSimulation(object = mcSimulation_results,
resultName = names(mcSimulation_results$y)[3], ncomp = 1)
input_table <- read.csv("Test_Input.csv")
plot_pls(pls_result, input_table = input_table, threshold = 0)
pls_result <- plsr.mcSimulation(object = mcSimulation_results,
resultName = names(mcSimulation_results$y)[3], ncomp = 1)
input_table <- read.csv("Test_Input.csv")
plot_pls(pls_result, input_table = input_table, threshold = 0)
?plot_pls
mcSimulation_table <- data.frame(mcSimulation_results$x, mcSimulation_results$y[1:3])
evpi <- multi_EVPI(mc = mcSimulation_table, first_out_var = "LLL_NPV")
plot_evpi(evpi, decision_vars = "NPV_decision_do")
plot_evpi(evpi, decision_vars = "LLL_NPV")
#> Warning: There are no variables with a positive EVPI. You probably do not need a
#> plot for that.
compound_figure(mcSimulation_object = mcSimulation_results, input_table = input_table, plsrResults = pls_result, EVPIresults = evpi, decision_var_name = "NPV_LLL_added_value", cashflow_var_name = "Cashflow_LLL_added_value", base_size = 7)
